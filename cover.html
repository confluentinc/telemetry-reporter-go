
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/confluentinc/telemetry-reporter-go/export/exporter.go (100.0%)</option>
				
				<option value="file1">github.com/confluentinc/telemetry-reporter-go/export/http.go (86.2%)</option>
				
				<option value="file2">github.com/confluentinc/telemetry-reporter-go/export/kafka.go (35.1%)</option>
				
				<option value="file3">github.com/confluentinc/telemetry-reporter-go/export/metric_to_pb.go (54.5%)</option>
				
				<option value="file4">github.com/confluentinc/telemetry-reporter-go/export/resource.go (100.0%)</option>
				
				<option value="file5">github.com/confluentinc/telemetry-reporter-go/export/stdout.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package export implements a library to create
// and define different custom OpenCensus metrics
// exporters.
package export

import (
        "sync"
        "time"

        "go.opencensus.io/metric/metricexport"
)

// ExporterAgent defines the wrapper format of exporters
// and data needed by all general exporters.
type ExporterAgent struct {
        metricexport.Exporter
        ir             *metricexport.IntervalReader
        initReaderOnce sync.Once
}

// Config defines the data format of the general
// configurations of an exporter.
type Config struct {
        IncludeFilter               string
        reportingPeriodMilliseconds int
}

// NewConfig returns a new exporter Config.
func NewConfig(filter string, reportingPeriod int) Config <span class="cov8" title="1">{
        return Config{
                IncludeFilter:               filter,
                reportingPeriodMilliseconds: reportingPeriod,
        }
}</span>

// a user should never have to use this explicitly. They would
// simply instantiate an implemented exporter
func newExporterAgent(exporter metricexport.Exporter) *ExporterAgent <span class="cov8" title="1">{
        return &amp;ExporterAgent{
                Exporter: exporter,
        }
}</span>

// Start creates the ExporterAgent's IntervalReader (if needed),
// sets the reporting interval, and then starts the reader.
func (e *ExporterAgent) Start(reportingPeriodms int) error <span class="cov8" title="1">{
        e.initReaderOnce.Do(func() </span><span class="cov8" title="1">{
                e.ir, _ = metricexport.NewIntervalReader(&amp;metricexport.Reader{}, e.Exporter)
        }</span>)
        <span class="cov8" title="1">e.ir.ReportingInterval = time.Duration(reportingPeriodms) * time.Millisecond
        return e.ir.Start()</span>
}

// Stop stops the ExporterAgent's interval reader.
func (e *ExporterAgent) Stop() <span class="cov8" title="1">{
        if k, ok := e.Exporter.(Kafka); ok </span><span class="cov8" title="1">{
                k.Stop()
        }</span>

        <span class="cov8" title="1">e.ir.Stop()</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package export

import (
        "bytes"
        "context"
        "log"
        "net/http"
        "regexp"

        "go.opencensus.io/metric/metricdata"
        "google.golang.org/protobuf/proto"
)

// HTTP is an exporter that exports metrics to an
// HTTP endpoint
type HTTP struct {
        address   string
        apiKey    string
        apiSecret string
        headerMap map[string]string
        client    *http.Client
        config    Config
}

// NewHTTP returns a new exporter agent with an HTTP exporter attached
func NewHTTP(address string, apiKey string, apiSecret string, config Config) *ExporterAgent <span class="cov8" title="1">{
        headerMap := map[string]string{
                "Content-Type": "application/x-protobuf",
        }

        exporter := HTTP{
                address:   address,
                apiKey:    apiKey,
                apiSecret: apiSecret,
                headerMap: headerMap,
                client:    &amp;http.Client{},
                config:    config,
        }

        agent := newExporterAgent(exporter)
        if err := agent.Start(exporter.config.reportingPeriodMilliseconds); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">return agent</span>
}

// AddHeader adds a map of headers to the exporter for its HTTP request.
func (e *ExporterAgent) AddHeader(headerMap map[string]string) <span class="cov8" title="1">{
        for k, v := range headerMap </span><span class="cov8" title="1">{
                e.Exporter.(HTTP).headerMap[k] = v
        }</span>
}

// ExportMetrics converts the metrics to a metrics service request protobuf and
// makes a POST request with that payload to an HTTP endpoint.
func (e HTTP) ExportMetrics(ctx context.Context, data []*metricdata.Metric) error <span class="cov8" title="1">{
        includeData := []*metricdata.Metric{}
        resource, _ := TotDetector(ctx)

        for _, d := range data </span><span class="cov8" title="1">{
                if matched, _ := regexp.Match(e.config.IncludeFilter, []byte(d.Descriptor.Name)); matched </span><span class="cov8" title="1">{
                        d.Resource = resource
                        includeData = append(includeData, d)
                }</span>
        }

        <span class="cov8" title="1">metricsRequestProto := metricsToServiceRequest(includeData)
        payload, err := proto.Marshal(metricsRequestProto)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Marshalling error: %v", err)
        }</span>

        <span class="cov8" title="1">e.postMetrics(payload)

        return nil</span>
}

func (e HTTP) postMetrics(payload []byte) <span class="cov8" title="1">{
        req, _ := http.NewRequest("POST", e.address, bytes.NewBuffer(payload))
        req.SetBasicAuth(e.apiKey, e.apiSecret)

        for headerKey, headerVal := range e.headerMap </span><span class="cov0" title="0">{
                req.Header.Add(headerKey, headerVal)
        }</span>

        <span class="cov8" title="1">resp, err := e.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error sending request: %v", err)
        }</span>

        <span class="cov8" title="1">log.Println(resp)
        defer resp.Body.Close()</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package export

import (
        "context"
        "fmt"
        "log"
        "os"
        "regexp"
        "time"

        "github.com/confluentinc/confluent-kafka-go/kafka"
        "go.opencensus.io/metric/metricdata"
        "go.opencensus.io/stats"
        "go.opencensus.io/stats/view"
        "google.golang.org/protobuf/proto"
)

var (
        messagesSent    = stats.Int64("messages_sent", "the number of metric messages successfully sent", "1")
        messagesDropped = stats.Int64("messages_dropped", "the number of metric messages dropped", "1")
)

var (
        messagesSentView = &amp;view.View{
                Name:        "messages_sent",
                Measure:     messagesSent,
                Description: "the number of metric messages successfully sent",
                Aggregation: view.Count(),
        }

        messagesDropedView = &amp;view.View{
                Name:        "messages_dropped",
                Measure:     messagesDropped,
                Description: "the number of metric messages dropped",
                Aggregation: view.Sum(),
        }
)

// TopicConfig holds the configurations for Topic info
type TopicConfig struct {
        Topic         string
        NumPartitions int
        NumReplicas   int
}

// Kafka is an exporter that exports metrics to a
// Kafka broker.
type Kafka struct {
        config              Config
        kafkaConfig         *kafka.ConfigMap
        producer            *kafka.Producer
        topicInfo           TopicConfig
        messageFlushTimeSec int
        lastDroppedLogCount int
}

// NewKafka returns a new Kafka exporter
func NewKafka(config Config, kafkaConfig *kafka.ConfigMap, topicInfo TopicConfig) *ExporterAgent <span class="cov8" title="1">{
        if err := view.Register(messagesSentView, messagesDropedView); err != nil </span><span class="cov0" title="0">{
                log.Printf("Problem registering views: %v", err)
        }</span>

        <span class="cov8" title="1">createTopic(topicInfo, kafkaConfig)

        producer, err := kafka.NewProducer(kafkaConfig)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">kafka := Kafka{
                config:              config,
                kafkaConfig:         kafkaConfig,
                topicInfo:           topicInfo,
                producer:            producer,
                lastDroppedLogCount: 0,
                messageFlushTimeSec: 15,
        }

        agent := newExporterAgent(kafka)
        if err := agent.Start(kafka.config.reportingPeriodMilliseconds); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">return agent</span>
}

func createTopic(topicInfo TopicConfig, kafkaConfig *kafka.ConfigMap) <span class="cov8" title="1">{
        adminClient, err := kafka.NewAdminClient(kafkaConfig)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to create Admin client: %s\n", err)
                os.Exit(1)
        }</span>

        // Contexts are used to abort or limit the amount of time
        // the Admin call blocks waiting for a result.
        <span class="cov8" title="1">ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Create topics on cluster.
        // Set Admin options to wait for the operation to finish (or at most 60s)
        maxDuration, err := time.ParseDuration("60s")
        if err != nil </span><span class="cov0" title="0">{
                panic("time.ParseDuration(60s)")</span>
        }

        <span class="cov8" title="1">if topicInfo.NumPartitions != 0 &amp;&amp; topicInfo.NumReplicas != 0 </span><span class="cov0" title="0">{
                results, err := adminClient.CreateTopics(ctx,
                        []kafka.TopicSpecification{{
                                Topic:             topicInfo.Topic,
                                NumPartitions:     topicInfo.NumPartitions,
                                ReplicationFactor: topicInfo.NumReplicas,
                        }},
                        kafka.SetAdminOperationTimeout(maxDuration))

                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Problem during the topic creation: %v\n", err)
                        os.Exit(1)
                }</span>

                // Check for specific topic errors
                <span class="cov0" title="0">for _, result := range results </span><span class="cov0" title="0">{
                        if result.Error.Code() != kafka.ErrNoError &amp;&amp;
                                result.Error.Code() != kafka.ErrTopicAlreadyExists </span><span class="cov0" title="0">{
                                fmt.Printf("Topic creation failed for %s: %v",
                                        result.Topic, result.Error.String())
                                os.Exit(1)
                        }</span>
                }
        }

        <span class="cov8" title="1">adminClient.Close()</span>

}

// Stop closes the Kafka producer.
func (e Kafka) Stop() <span class="cov8" title="1">{
        defer e.producer.Close()
}</span>

// SetMessageFlushTime sets the time to wait to flush the
// Kafka message buffer. Default is 15 seconds
func (e *ExporterAgent) SetMessageFlushTime(seconds int) <span class="cov8" title="1">{
        newKafka := e.Exporter.(Kafka)
        newKafka.messageFlushTimeSec = seconds
        e.Exporter = newKafka
}</span>

// ExportMetrics converts the metrics to a metrics service request protobuf and
// makes a POST request with that payload to a Kafka broker.
func (e Kafka) ExportMetrics(ctx context.Context, data []*metricdata.Metric) error <span class="cov0" title="0">{
        go handleEvents(e.producer.Events())

        for _, d := range data </span><span class="cov0" title="0">{
                if matched, _ := regexp.Match(e.config.IncludeFilter, []byte(d.Descriptor.Name)); matched </span><span class="cov0" title="0">{
                        d.Resource, _ = TotDetector(ctx)
                        metricsRequestpb := metricToProto(d)
                        payload, err := proto.Marshal(metricsRequestpb)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Marshalling Error: %v", err)
                        }</span>

                        <span class="cov0" title="0">err = e.producer.Produce(&amp;kafka.Message{
                                TopicPartition: kafka.TopicPartition{
                                        Topic:     &amp;e.topicInfo.Topic,
                                        Partition: kafka.PartitionAny,
                                },
                                Value: payload,
                        }, nil)

                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error sending message with Producer: %v", err)
                        }</span>
                }
        }

        <span class="cov0" title="0">droppedCount := e.producer.Flush(e.messageFlushTimeSec * 1000)
        stats.Record(context.Background(), messagesDropped.M(int64(droppedCount)))
        droppedDelta := droppedCount - e.lastDroppedLogCount

        if droppedDelta &gt; 0 </span><span class="cov0" title="0">{
                log.Println("Failed to produce %i metrics messages", droppedDelta)
        }</span>

        <span class="cov0" title="0">e.lastDroppedLogCount = droppedCount

        return nil</span>
}

func handleEvents(events chan kafka.Event) <span class="cov0" title="0">{
        for e := range events </span><span class="cov0" title="0">{
                switch ev := e.(type) </span>{
                case *kafka.Message:<span class="cov0" title="0">
                        if ev.TopicPartition.Error != nil </span><span class="cov0" title="0">{
                                stats.Record(context.Background(), messagesDropped.M(1))
                        }</span> else<span class="cov0" title="0"> {
                                stats.Record(context.Background(), messagesSent.M(1))
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package export

import (
        "fmt"

        a1 "github.com/census-instrumentation/opencensus-proto/gen-go/agent/metrics/v1"
        v1 "github.com/census-instrumentation/opencensus-proto/gen-go/metrics/v1"
        r1 "github.com/census-instrumentation/opencensus-proto/gen-go/resource/v1"
        "github.com/golang/protobuf/ptypes"
        "github.com/golang/protobuf/ptypes/wrappers"
        "go.opencensus.io/metric/metricdata"
        "go.opencensus.io/resource"
)

func metricsToServiceRequest(ms []*metricdata.Metric) *a1.ExportMetricsServiceRequest <span class="cov8" title="1">{
        metrics := []*v1.Metric{}

        for _, m := range ms </span><span class="cov8" title="1">{
                toAppend := metricToProto(m)
                metrics = append(metrics, toAppend)
        }</span>

        <span class="cov8" title="1">return &amp;a1.ExportMetricsServiceRequest{
                Metrics: metrics,
        }</span>
}

func metricToProto(m *metricdata.Metric) *v1.Metric <span class="cov8" title="1">{
        return &amp;v1.Metric{
                MetricDescriptor: metricToDescriptor(m),
                Timeseries:       metricToTimeSeries(m),
                Resource:         resourceToProto(m.Resource),
        }
}</span>

func metricToLabelKeys(m *metricdata.Metric) []*v1.LabelKey <span class="cov8" title="1">{
        labelKeys := []*v1.LabelKey{}

        for _, lk := range m.Descriptor.LabelKeys </span><span class="cov8" title="1">{
                toAppend := &amp;v1.LabelKey{
                        Key:         lk.Key,
                        Description: lk.Description,
                }

                labelKeys = append(labelKeys, toAppend)
        }</span>
        <span class="cov8" title="1">return labelKeys</span>
}

func metricToDescriptor(m *metricdata.Metric) *v1.MetricDescriptor <span class="cov8" title="1">{
        return &amp;v1.MetricDescriptor{
                Name:        m.Descriptor.Name,
                Description: m.Descriptor.Description,
                Unit:        string(m.Descriptor.Unit),
                Type:        metricdataTypetoProtoType(m.Descriptor.Type),
                LabelKeys:   metricToLabelKeys(m),
        }
}</span>

/*
We need this function since OpenCensus Metric Enum types are offset by one in
the protobuf format
see https://github.com/census-instrumentation/opencensus-go/blob/master/metric/metricdata/point.go#L185-L193
and https://github.com/census-instrumentation/opencensus-proto/blob/master/gen-go/metrics/v1/metrics.pb.go#L61-L89
*/
func metricdataTypetoProtoType(metricType metricdata.Type) v1.MetricDescriptor_Type <span class="cov8" title="1">{
        return v1.MetricDescriptor_Type(metricType + 1)
}</span>

func resourceToProto(r *resource.Resource) *r1.Resource <span class="cov8" title="1">{
        if r != nil </span><span class="cov8" title="1">{
                return &amp;r1.Resource{
                        Type:   r.Type,
                        Labels: r.Labels,
                }
        }</span>

        <span class="cov8" title="1">return nil</span>

}

func metricToTimeSeries(m *metricdata.Metric) []*v1.TimeSeries <span class="cov8" title="1">{
        timeSeries := []*v1.TimeSeries{}

        for _, ts := range m.TimeSeries </span><span class="cov8" title="1">{
                timestamp, _ := ptypes.TimestampProto(ts.StartTime)

                toAppend := &amp;v1.TimeSeries{
                        StartTimestamp: timestamp,
                        LabelValues:    metricToLabelValues(ts),
                        Points:         metricToPoints(ts),
                }

                timeSeries = append(timeSeries, toAppend)
        }</span>

        <span class="cov8" title="1">return timeSeries</span>
}

func metricToLabelValues(t *metricdata.TimeSeries) []*v1.LabelValue <span class="cov8" title="1">{
        labelValues := []*v1.LabelValue{}

        for _, lv := range t.LabelValues </span><span class="cov8" title="1">{
                toAppend := &amp;v1.LabelValue{
                        Value:    lv.Value,
                        HasValue: lv.Present,
                }

                labelValues = append(labelValues, toAppend)
        }</span>

        <span class="cov8" title="1">return labelValues</span>
}

func metricToPoints(t *metricdata.TimeSeries) []*v1.Point <span class="cov8" title="1">{
        points := []*v1.Point{}

        for _, p := range t.Points </span><span class="cov8" title="1">{
                timestamp, _ := ptypes.TimestampProto(p.Time)
                toAppend := &amp;v1.Point{
                        Timestamp: timestamp,
                }

                switch v := p.Value.(type) </span>{
                case int64:<span class="cov8" title="1">
                        toAppend.Value = &amp;v1.Point_Int64Value{
                                Int64Value: v,
                        }</span>
                case float64:<span class="cov8" title="1">
                        toAppend.Value = &amp;v1.Point_DoubleValue{
                                DoubleValue: v,
                        }</span>
                case *metricdata.Summary:<span class="cov0" title="0">
                        toAppend.Value = &amp;v1.Point_SummaryValue{
                                SummaryValue: pointToSummaryValue(v),
                        }</span>
                case *metricdata.Distribution:<span class="cov0" title="0">
                        toAppend.Value = &amp;v1.Point_DistributionValue{
                                DistributionValue: pointToDistributionValue(v),
                        }</span>
                default:<span class="cov0" title="0">
                        panic("unsupported value type")</span>
                }

                <span class="cov8" title="1">points = append(points, toAppend)</span>
        }

        <span class="cov8" title="1">return points</span>
}

func pointToSummaryValue(value *metricdata.Summary) *v1.SummaryValue <span class="cov0" title="0">{
        return &amp;v1.SummaryValue{
                Count:    &amp;wrappers.Int64Value{Value: value.Count},
                Sum:      &amp;wrappers.DoubleValue{Value: value.Sum},
                Snapshot: summaryValToSnapshot(value),
        }
}</span>

func summaryValToSnapshot(summary *metricdata.Summary) *v1.SummaryValue_Snapshot <span class="cov0" title="0">{
        snapshot := &amp;v1.SummaryValue_Snapshot{}

        if summary.HasCountAndSum </span><span class="cov0" title="0">{
                snapshot.Count = &amp;wrappers.Int64Value{Value: summary.Snapshot.Count}
                snapshot.Sum = &amp;wrappers.DoubleValue{Value: summary.Snapshot.Sum}
        }</span>

        <span class="cov0" title="0">percentileValues := []*v1.SummaryValue_Snapshot_ValueAtPercentile{}
        for percentile, val := range summary.Snapshot.Percentiles </span><span class="cov0" title="0">{
                toAppend := &amp;v1.SummaryValue_Snapshot_ValueAtPercentile{
                        Percentile: percentile,
                        Value:      val,
                }
                percentileValues = append(percentileValues, toAppend)
        }</span>

        <span class="cov0" title="0">snapshot.PercentileValues = percentileValues
        return snapshot</span>
}

func pointToDistributionValue(value *metricdata.Distribution) *v1.DistributionValue <span class="cov0" title="0">{
        return &amp;v1.DistributionValue{
                Count:                 value.Count,
                Sum:                   value.Sum,
                SumOfSquaredDeviation: value.SumOfSquaredDeviation,
                Buckets:               distributionToBuckets(value),
                BucketOptions:         distributionToBucketOptions(value),
        }
}</span>

func distributionToBuckets(value *metricdata.Distribution) []*v1.DistributionValue_Bucket <span class="cov0" title="0">{
        buckets := []*v1.DistributionValue_Bucket{}

        for _, bucket := range value.Buckets </span><span class="cov0" title="0">{
                buckets = append(buckets, bucketToProto(bucket))
        }</span>

        <span class="cov0" title="0">return buckets</span>
}

func bucketToProto(bucket metricdata.Bucket) *v1.DistributionValue_Bucket <span class="cov0" title="0">{
        res := &amp;v1.DistributionValue_Bucket{
                Count: bucket.Count,
        }

        if bucket.Exemplar != nil </span><span class="cov0" title="0">{
                res.Exemplar = bucketToExemplar(bucket)
        }</span>

        <span class="cov0" title="0">return res</span>
}

func bucketToExemplar(bucket metricdata.Bucket) *v1.DistributionValue_Exemplar <span class="cov0" title="0">{
        timestamp, _ := ptypes.TimestampProto(bucket.Exemplar.Timestamp)

        return &amp;v1.DistributionValue_Exemplar{
                Value:       bucket.Exemplar.Value,
                Timestamp:   timestamp,
                Attachments: bucketToAttachments(bucket),
        }
}</span>

func bucketToAttachments(bucket metricdata.Bucket) map[string]string <span class="cov0" title="0">{
        res := map[string]string{}

        for k, v := range bucket.Exemplar.Attachments </span><span class="cov0" title="0">{
                res[k] = fmt.Sprintf("%v", v)
        }</span>

        <span class="cov0" title="0">return res</span>
}

func distributionToBucketOptions(value *metricdata.Distribution) *v1.DistributionValue_BucketOptions <span class="cov0" title="0">{
        return &amp;v1.DistributionValue_BucketOptions{
                Type: &amp;v1.DistributionValue_BucketOptions_Explicit_{
                        Explicit: &amp;v1.DistributionValue_BucketOptions_Explicit{
                                Bounds: value.BucketOptions.Bounds,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package export

import (
        "context"
        "os"
        "runtime"

        "go.opencensus.io/resource"
)

var (
        // TotDetector returns a Detector that combines the resources
        // of the following detectors
        TotDetector = resource.MultiDetector(hostnameDetector, goDetector)
)

func goDetector(context.Context) (*resource.Resource, error) <span class="cov8" title="1">{
        resourceType := "golang"
        labels := map[string]string{
                resourceType + ".version": runtime.Version(),
        }

        return &amp;resource.Resource{
                Type:   resourceType,
                Labels: labels,
        }, nil
}</span>

func hostnameDetector(context.Context) (*resource.Resource, error) <span class="cov8" title="1">{
        resourceType := "host"

        hostname, _ := os.Hostname()

        labels := map[string]string{
                resourceType + ".hostname": hostname,
        }

        return &amp;resource.Resource{
                Type:   resourceType,
                Labels: labels,
        }, nil
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package export

import (
        "context"
        "log"

        "go.opencensus.io/metric/metricdata"
)

// Stdout is an exporter that exports metrics to stdout.
type Stdout struct {
        config Config
}

// NewStdout returns a new Stdout exporter.
func NewStdout(config Config) Stdout <span class="cov0" title="0">{
        return Stdout{
                config: config,
        }
}</span>

// ExportMetrics prints the metrics' names, description, and values.
func (e Stdout) ExportMetrics(ctx context.Context, data []*metricdata.Metric) error <span class="cov0" title="0">{
        for _, d := range data </span><span class="cov0" title="0">{
                log.Printf(d.Descriptor.Name)
                log.Printf(d.Descriptor.Description)
                for _, ts := range d.TimeSeries </span><span class="cov0" title="0">{
                        for _, point := range ts.Points </span><span class="cov0" title="0">{
                                log.Printf("value=%v", point.Value)
                        }</span>
                }
                <span class="cov0" title="0">log.Printf("\n\n")</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
